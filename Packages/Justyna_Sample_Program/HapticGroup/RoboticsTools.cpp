///////////////////////////////////////////////////////////////////////////////////////////////////
//  RoboticsTools.h
///////////////////////////////////////////////////////////////////////////////////////////////////
//  This source file includes functions related to robotics (kinematics, Jacobian, etc.)
///////////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//  Programmer:		Masayuki HARA (Assitant Professor)
//  Affiliation:	Higuchi & Yamamoto Lab. (Advanced Mechatoronics Lab.)
//					School of Engineering, The University of Tokyo
//  Created date:	22.10.2009
//	Updated date:	22.10.2009
///////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
//  include

#include <windows.h>
#include <math.h>
#include <stdio.h>

#include "resource.h"

#include "DeviceControl.h"
#include "IOControl.h"
#include "SamplerTools.h"
#include "RoboticsTools.h"


///////////////////////////////////////////////////////////////////////////////////////////////////
//  define



///////////////////////////////////////////////////////////////////////////////////////////////////
//  variable

HANDLE hEndEvent;											//  Handle for the end of event

ULONG ulCalTimerCounter;									//  Timer counter for caribration

double dOffsetVoltageAvg = 2.517;							//  Average offset voltage [V]
double dOffsetVoltageSum;									//  Sum of offset voltage [V]

const double dLinkLength[3] = {0.0, 100.0, 132.0};			//  Leink lenghts of 3-DOF robot
const double dPulleyRadius = 7.5;							//  Pulley radius


///////////////////////////////////////////////////////////////////////////////////////////////////
//  function

void RT_CalibrationSampler(void);


///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
//  Robotic kinematics
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
//  void RT_GetRotationMatrix(double *, double r_mtx[3][3])
///////////////////////////////////////////////////////////////////////////////////////////////////
//  Get rotation matrix in the base coordination system
///////////////////////////////////////////////////////////////////////////////////////////////////
void RT_GetRotationMatrix(double *angle, double r_mtx[3][3])
{
	//  Get rotation matrix
	r_mtx[0][0] = sin(angle[1] + angle[2]);
	r_mtx[0][1] = cos(angle[1] + angle[2]);
	r_mtx[0][2] = 0.0;

	r_mtx[1][0] = 0.0;
	r_mtx[1][1] = 0.0;
	r_mtx[1][2] = 1.0;

	r_mtx[2][0] = cos(angle[1] + angle[2]);
	r_mtx[2][1] = -sin(angle[1] + angle[2]);
	r_mtx[2][2] = 0.0;
}

//  void RT_GetRotationMatrix(double *, double r_mtx[3][3])
///////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////
//  void RT_GetHomogeneousTransformationMatrix(double *, double t_mtx[4][4])
///////////////////////////////////////////////////////////////////////////////////////////////////
//  Get rotation matrix in the base coordination system
///////////////////////////////////////////////////////////////////////////////////////////////////
void RT_GetHomogeneousTransformationMatrix(double *angle, double t_mtx[4][4])
{
	//  Get homogeneous transformation matrix
	t_mtx[0][0] = sin(angle[1] + angle[2]);
	t_mtx[0][1] = cos(angle[1] + angle[2]);
	t_mtx[0][2] = 0.0;
	t_mtx[0][3] = 0.0;

	t_mtx[1][0] = 0.0;
	t_mtx[1][1] = 0.0;
	t_mtx[1][2] = 1.0;
	t_mtx[1][3] = 0.0;

	t_mtx[2][0] = cos(angle[1] + angle[2]);
	t_mtx[2][1] = -sin(angle[1] + angle[2]);
	t_mtx[2][2] = 0.0;
	t_mtx[2][3] = dLinkLength[0] + dLinkLength[1] * cos(angle[0]) 
		+ dLinkLength[2] * cos(angle[1] + angle[2]);

	t_mtx[3][0] = 0.0;
	t_mtx[3][1] = 0.0;
	t_mtx[3][2] = 0.0;
	t_mtx[3][3] = 1.0;
}

//  void RT_GetHomogeneousTransformationMatrix(double *, double t_mtx[4][4])
///////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////
//  void RT_CalculateDirectKinematics(double *, double *)
///////////////////////////////////////////////////////////////////////////////////////////////////
//  Calculate robotic direct kinematics
///////////////////////////////////////////////////////////////////////////////////////////////////
void RT_CalculateDirectKinematics(double *angle, double *position)
{
	//  Calculate a tip position of robot from joint angles
	position[0] = dLinkLength[1] * sin(angle[1]) + dLinkLength[2] * sin(angle[1] + angle[2]);
	position[1] = 2.0 * dPulleyRadius * angle[0] / 2.0;
	position[2] = dLinkLength[0] + dLinkLength[1] * cos(angle[1]) 
		+ dLinkLength[2] * cos(angle[1] + angle[2]);
}

//  void RT_CalculateDirectKinematics(double *, double *)
///////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////
//  void RT_CalculateInverseKinematics(double *, double *)
///////////////////////////////////////////////////////////////////////////////////////////////////
//  Calculate robotic inverse kinematics
///////////////////////////////////////////////////////////////////////////////////////////////////
void RT_CalculateInverseKinematics(double *position, double *angle)
{
	double r, l1, l2;

	//  Calculate parameters
	r = pow(position[0], 2) + pow(position[2], 2);
	l1 = pow(dLinkLength[1], 2);
	l2 = pow(dLinkLength[2], 2);

	//  Calculate joint angles from a tip position
	angle[0] = 2.0 * position[1] / dPulleyRadius / 2.0;
	angle[1] = atan2(position[0], position[2]) 
		- acos((l1 + r - l2) / (2.0 * dLinkLength[1] * sqrt(r)));
	angle[2] = PI - acos((l1 + l2 - r) / (2.0 * dLinkLength[1] * dLinkLength[2]));
}

//  void RT_CalculateInverseKinematics(double *, double *)
///////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
//  Calibration of force sensor and acquisition of applied force data
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
//  void RT_InitSamplerForCalibration(void)
///////////////////////////////////////////////////////////////////////////////////////////////////
//	Initialize sampler for calibration of force sensor
///////////////////////////////////////////////////////////////////////////////////////////////////
void RT_InitSamplerForCalibration(void)
{
	unsigned int i, j;

	//  Initialize timer and error counters
	ulCalTimerCounter = 0;
	dOffsetVoltageSum = 0;

	//  Create the handle for the end of event
	hEndEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	
	//  Start sampler
	SamplerOn(&RT_CalibrationSampler);

	//  Wait until the end of event
	WaitForSingleObject(hEndEvent, INFINITE);

	//  Stop sampler
	SamplerOff();

	//  Close the event handle
	CloseHandle(hEndEvent);
}  

//  void RT_InitSamplerForCalibration(void)
///////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////
//  void RT_CalibrationSampler(void)
///////////////////////////////////////////////////////////////////////////////////////////////////
//	Initialize sampler for cariblation of force sensor
///////////////////////////////////////////////////////////////////////////////////////////////////
void RT_CalibrationSampler(void)
{
	unsigned int i;
	double input;

	//  Get an input voltage
	IO_GetAnalogVoltage(&input);

	//  Calculate the sum of offset voltage
	dOffsetVoltageSum += input;

	ulCalTimerCounter++;								//	Count up

	//  End of calibration
	if (ulCalTimerCounter > (5.0 / SAMP)) {				//  Cariblation for 5 sec
		//  Calculate the average offset voltage
		dOffsetVoltageAvg = dOffsetVoltageSum / ulCalTimerCounter;

		//  End of the event
		SetEvent(hEndEvent);
	}
}

//  void RT_CalibrationSampler(void)
///////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////
//  double RT_GetSingleForce(void)
///////////////////////////////////////////////////////////////////////////////////////////////////
//	Get an applied force from a load cell
///////////////////////////////////////////////////////////////////////////////////////////////////
double RT_GetSingleForce(void)
{
	double input;
	double force;

	//  Get analog input voltage
	IO_GetAnalogVoltage(&input);

	//  Calculate applied force
	force = 25.181 * (dOffsetVoltageAvg - input);//29.337 * (dOffsetVoltageAvg - input);

	return force;
}

//  double RT_GetSingleForce(void)
///////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////
//  void RT_GetForceVector(double *, double, double *)
///////////////////////////////////////////////////////////////////////////////////////////////////
//	Get an applied force vector from an applied force
///////////////////////////////////////////////////////////////////////////////////////////////////
void RT_GetForceVector(double *angle, double applied_force, double *force)
{
//	double applied_force;

	//  Get an applied force
//	applied_force = RT_GetSingleForce();

	//  Calculate the applied force vector
	force[0] = -applied_force * sin(angle[1] + angle[2]);
	force[1] = 0.0;
	force[2] = -applied_force * cos(angle[1] + angle[2]);
}

//  void RT_GetForceVector(double *, double, double *)
///////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////
//  double RT_GetPotentiometerPosition(void)
///////////////////////////////////////////////////////////////////////////////////////////////////
//	Get potentiometer position [mm]
///////////////////////////////////////////////////////////////////////////////////////////////////
double RT_GetPotentiometerPosition(void)
{
	double input;
	double pos;

	//  Get analog input voltage
	IO_GetAnalogVoltage(&input);

	//  Calculate the position (LS852: 25 mm)
	pos = 25.0 / (3.67 - 1.4) * (input - 2.5);

	return pos;
}

//  double RT_GetPotentiometerPosition(void)
///////////////////////////////////////////////////////////////////////////////////////////////////